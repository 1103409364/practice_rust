pub fn factors(mut n: u64) -> Vec<u64> {
    // todo!("This should calculate the prime factors of {n}")
    let mut factors = Vec::new();
    let mut i = 2;
    // 通过逐步分解保证质数因子，所以不用判断质数
    while i * i <= n {
        if n % i == 0 {
            factors.push(i);
            n /= i;
        } else {
            i += 1;
        }
    }
    if n > 1 {
        factors.push(n);
    }
    factors
}

// `factors` 函数为什么不需要显式地检查 `i` 和 `n` 是否为质数。

// **核心概念：通过逐步分解保证质数因子**

// 这个算法的核心思想是，它通过从小到大逐步尝试除数，来保证找到的因子一定是质数。  以下是具体解释：

// 1. **从最小的质数 2 开始：** 循环从 `i = 2` 开始。  这意味着我们首先尝试用最小的质数 2 去除 `n`。

// 2. **重复除以最小因子：**  关键在于 `while n % i == 0 { ... n /= i; }` 这个循环。  只要 `i` 是 `n` 的一个因子，我们就**反复**地用 `i` 去除 `n`，直到 `n` 不能再被 `i` 整除为止。

// 3. **`i` 递增的含义：** 只有当 `n` 不能被 `i` 整除时，`i` 才会递增。  这意味着：
//    *  在 `i` 增加到下一个值之前，`n` 已经不再包含任何 `i` 的因子。
//    *  如果 `i` 不是质数（例如，`i` 是 4），那么当循环进行到 `i = 4` 时，`n` 必然已经不能被 2 整除（因为我们已经用 2 除尽了 `n`）。  也就是说，`n` 不可能包含任何 4 的因子，因为如果它包含 4 的因子，它也必然包含 2 的因子，而这与前面的步骤矛盾。

// 4. **`n > 1` 的含义：**  当 `while i * i <= n` 循环结束时，如果 `n > 1`，那么剩下的 `n` 一定是一个质数。  这是因为：
//    *  如果 `n` 不是质数，那么它必然有一个小于 `sqrt(n)` 的因子。
//    *  但是，所有小于 `sqrt(n)` 的因子已经在之前的循环中被尝试过了。
//    *  因此，如果循环结束后 `n > 1`，那么 `n` 必然是一个质数。

// **举例说明**

// 假设我们要分解 `n = 28`：

// 1. `i = 2`，`28 % 2 == 0`，所以 `factors.push(2)`，`n = 28 / 2 = 14`。
// 2. `i = 2`，`14 % 2 == 0`，所以 `factors.push(2)`，`n = 14 / 2 = 7`。
// 3. `i = 2`，`7 % 2 != 0`，所以 `i` 增加到 3。
// 4. `i = 3`，`7 % 3 != 0`，所以 `i` 增加到 4。
// 5. `i = 4`，`4 * 4 > 7`，循环结束。
// 6. `n > 1`，所以 `factors.push(7)`。

// 最终结果是 `factors = [2, 2, 7]`。

// **总结**

// 通过逐步分解的方式，巧妙地保证了找到的因子一定是质数。这种算法避免了质数判断，提高了效率。
